// This file is Copyright its original authors, visible in version control
// history.
//
// This file is licensed under the Apache License, Version 2.0 <LICENSE-APACHE
// or http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your option.
// You may not use this file except in accordance with one or both of these
// licenses.
//
// This module will receive a serialized payload from the BoardManager and
// pack them into an anchor(?) and at periodic intervals, counter-sign them
// with the Board pubkey and submit for validation on the Mainstay server.
// 

use bitcoin::secp256k1::{PublicKey};
use std::collections::HashMap;
use std::hash::{Hash, Hasher};

// AnchorManager will receive events from the BoardManager, independently of 
// the communications channels (BOLT4 onions, BOLT8 noise channel or NIP 01 
// websocket) and sources (clients or peers).

// The AnchorManager (in anchormanager.rs) should accept serialized event 
// payload (BOLT4 onions, BOLT8 noise channel or NIP 01 WS) from the 
// BoardManager, pack them in an anchor and at periodic intervals (e.g every 
// X blocks or clock ticks), counter-sign them with the board public key and 
// submit for validation to the selected Mainstay server.

// The anchor format should be some metadata (version, time, previous anchor 
// SHA256 hash if proof-of-immutable-sequence is opted-in) and a byte payload.

// The Mainstay protocol is documented here: 
// https://commerceblock.readthedocs.io/en/latest/mainstay-background/index.html
// and the original paper is available here: 
// https://cloudflare-ipfs.com/ipns/ipfs.commerceblock.com/commerceblock-whitepaper-mainstay.pdf

#[derive(PartialEq, Eq, Hash, Debug)]
pub struct Board(PublicKey);

#[derive(Debug)]
pub struct AnchorManager {
    our_events: HashMap<Board, Vec<SerializedEvent>>
}

#[derive(Debug)]
pub struct SerializedEvent {
    event: String,
    meta: String
}

impl AnchorManager {
    pub fn new() -> Self {
        AnchorManager {
            our_events: HashMap::new()
        }
	  }

    fn add_event(&mut self, board: Board, offer: SerializedEvent) {
        // Collects events generated by a specific board
        // TODO:  Write these events to temporary storage until they have
        // been recorded on Mainstay. 
        let events = self.our_events
            .entry(board)
            .or_insert_with(Vec::new);
        events.push(offer);
    }
    
    fn events_for_board(&self, board: Board) -> Option<&Vec<SerializedEvent>> {
        self.our_events.get(&board)
    }

    fn record_events_for_board(&self, board: Board) -> bool {
        //TODO record the set of events for this board on Mainstay and 
        //remove them from temporary storage.
        unimplemented!();
    }
}


#[cfg(test)]
mod tests {
 
    use crate::anchormanager::AnchorManager;
    use bitcoin::secp256k1::{SecretKey, PublicKey};
    use bitcoin::secp256k1::Secp256k1;
    use crate::anchormanager::SerializedEvent;
    use crate::anchormanager::Board;
    
    #[test]
    fn add_events() {
				let secp_ctx = Secp256k1::new();
				let pubkey = PublicKey::from_secret_key(&secp_ctx, &SecretKey::from_slice(&[42;32]).unwrap());

        let event1 = SerializedEvent {event: "event1".to_string(), meta: "meta1".to_string()};
        let event2 = SerializedEvent {event: "event2".to_string(), meta: "meta2".to_string()};
        
        let mut my_anchor = AnchorManager::new();
        
        my_anchor.add_event(Board(pubkey), event1);
        my_anchor.add_event(Board(pubkey), event2);

        let num_events = match my_anchor.events_for_board(Board(pubkey)) {
            Some(e) => e.len(),
            None => 0,
        };
        
        assert_eq!(num_events, 2);
    }
}
